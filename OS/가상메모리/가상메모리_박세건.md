# 가상 메모리란
>실제 메모리에 여러 프로그램들을 실행하기 위해서는 메모리의 크기는 부족하다. 이러한 문제를 해결하기위해서 **물리 메모리의 크기의 상관없이 메모리를 이용할 수 있도록 하는 기술이 가상 메모리** 입니다.
예를 들어서 2GB의 메모리를 갖는 컴퓨터에서는 실행이 가능한 프로세스가 1GB의 메모리 사용하는 컴퓨터는 사용할 수 없는 상황이 발생하고 이러한 문제를 고려해서 프로그래밍 하는 것은 매우 어렵습니다. 가상 메모리는 이러한 문제를 해결할 수 있는 것입니다.
즉, 각각의 다른 물리 메모리를 사용하는 상황에서 일관되게 프로세스를 실행할 수 있도록 하는 기술입니다.

## 개념
>물리 메모리의 크기와 프로세스를 메모리의 어느 위치에 올려야 하는지를 신경 쓰지 않고 프로그래밍 가능합니다.
프로세스는 운영체제가 어디있는지 크기가 어느정도인지를 신경쓰지 않고 사용할 수 있습니다.

## 가상 메모리의 크기와 주소
가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 어느 위치에 상관없이 **0번지부터 시작하는 연속된 메모리 공간을 갖는다.** 물리 메모리의 주소 공간에 비례한 **논리 주소**와 다른점은 **가상 주소**는 물리 메모리 공간이 아니라 가상의 공간을 갖는다는 것이다.

---

![](https://velog.velcdn.com/images/parksegun/post/c574741f-160e-407e-9fc8-ff4df8b84643/image.png)

가상 메모리 공간은 크기 **프로세스가 바라보는 가상 메모리 영역**과 **메모리 관리자가 바라보는 가상 메모리 영역** 으로 나눠집니다.

#### 가상 메모리는 이론상 무한대의 크기를 갖지만 실제로는 물리 메모리의 최대 크기로 한정됩니다.
물리 메모리의 크기는 CPU의 비트에 따라 결정됩니다.
- 32bit : 2^32-1 즉, 4GB
즉, 32bit의 CPU에서는 가상 메모리의 최대 크기는 4GB(물리 메모리 크기)입니다.
### 어떻게 이론적으로 무한대의 크기처럼 구현할 수 있을까
> 가상 메모리 시스템은 물리메모리의 일부 내용을 하드디스크의 일부 공간으로 옮깁니다.
이때 사용하는 하드디스크의 일부 공간을 **스왑 영역** 이라고합니다.
이 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역이고 물리 메모리의 부족한 영역을 스왑 영역으로 보충합니다.
즉, 물리 메모리가 가득 차서 사용할 수 없을때 일부 프로세스를 스왑 영역으로 보내고(스왑 아웃), 몇개의 프로세스 작업을 끝냈을때 다시 스왑 영역에서 물리 메모리로 가져옵니다(스왑 인)
_따라서 가상 메모리에서 메모리 관리자가 사용할 수 있는 공간은 물리 메모리 + 스왑 영역 입니다._

가상 메모리 시스템에서 메모리 관리자는 프로세스가 사용하는 가상 주소를 실제 물리 메모리 주소로 변환 해야합니다. 이 과정을 **동적 주소 변환(Dynamic Address Translation, DAT) 라고 합니다.**
이 과정에서 메모리 관리자는 **물리 메모리를 어떤 방법으로 나눌지**, **어디에 배치할지** **부족한 메모리를 어떻게 처리할 지** 와 같은 문제를 처리해야합니다.

---

## 가상 메모리의 분할 방식
> 물리 메모리의 0번지는 운영체제으 영역이고 일반 프로세스가 사용할 수 없습니다.
가상 메모리 시스템은 운영체제 영역은 제외한 영역을 **일정한 크기**로 나누어 프로세스에게 할당합니다.
이 때 나누는 분할 방식을 이용한 메모리 관리 기법은 크게 두가지가 있다.
- 가변 분할 방식
  - 세그먼테이션
  - 단점 : 외부 단편화 등의 문제 발생
- 고정 분할 방식
  - 페이징 
  - 단점 : 페이지 관리가 어려움
각각의 메모리 관리 기법들의 단점을 보완하기 위해 **세그멘테이션-페이지 혼용** 기법을 사용합니다.

---

## Mapping 테이블의 필요성과 역할
메모리를 관리 할때, 가상 주소는 실제로 물리 주소나 스왑 영역 중 한곳에 위치 해야하고 가상 주소와 물리 주소는 1:1 매핑 테이블을 통해 관리합니다.
때문에 프로세스의 어떤 값이 필요할 때 물리 메모리에서 해당하는 세그먼트를 찾아서 가져오면됩니다.
![](https://velog.velcdn.com/images/parksegun/post/b1a5e316-eb2f-412a-a450-610a75dcdcc3/image.png)

위와 같은 과정은 페이징으로 분할된 방식에서도 같이 사용되며 페이징 기법에서 사용되는 매핑 테이블은 **페이지 테이블** 이라고 하고 세그먼테이션 기법에서 사용되는 테이블은 **세그먼테이션 테이블** 이라고합니다.
#### 메모리 관리 장치(Memory Management Unit)이 페이지 테이블을 이용해서 논리적 주소를 물리적 주소로 매핑합니다.

#### 메모리 공간은 항상 0번지 부터 시작합니다.


---

# 페이징 기법
> 고정 분할 방식을 이용한 가상 메모리 관리 기법 입니다.
물리 주소 공간을 같은 서로 일정하고 같은 크기로 나누어서 사용합니다.
가상 주소를 나눈 영역 : 페이지
물리 주소를 나눈 영역 : 프레임
이 둘의 크기는 같습습니다.
![](https://velog.velcdn.com/images/parksegun/post/d52d6141-37a0-47eb-979d-db8a0331371a/image.png)
가상 페이지지가 물리 메모리에 어떤 위치에 저장되어있는지는 매핍 테이블에 담겨져있다.
_ 스왑 영역에 있으면 **invalid**라고 나타낸다._

---

# 페이징 기법의 주소 변환
![](https://velog.velcdn.com/images/parksegun/post/93553444-d42b-46e0-a3fa-70a973f848d7/image.png)
_메모리는 1Byte 기준으로 적용된다_
>만약, 페이지와 프레임의 크기를 10Byte로 설정하며 한 페이지에는 10개의 주소를 저장할 수 있습니다. 1Byte가 1개의 주소로 설정되기 때문.
그렇다면 각각의 페이지와, 프레임에는 10개의 주소를 갖게됩니다.
위 그림에서 만약 가상 주소 18번지에 접근하고 싶은 상황을 살펴보자
1. 가상 주소 18번지가 어느 페이지에 있는지 탐색합니다 -> 가상 주소 18번지는 1번 페이지 8번째에 위치합니다.
2. 페이지 테이블의 1번 페이지는 물리 메모리의 3번 프레임에 위치한다는 것을 알아낸다.
3. 3번 프레임의 8번째 위치에 접근합니다.

---

## 정형화된 주소 변환
_정형화 : 일정한 형식이나 틀로 설정하는 것_
>페이징 기법은 가상 주소를 VA=<P,D> 로 표현한다. 
- VA : Virtual Address -> 가상주소
- P : Page -> 페이지
- D : Distance -> 페이지 처음 위치에서 주소까지 거리
이러한 방식으로 물리주소는 PA=<F,D> 라고 표현한다.
때문에 주소 변환 과정은 VA=<P,D> -> PA=<F,D> 로 나타내는 과정을 의미합니다.
ex) VA=<56,7> 은 26페이지에 7번째 주소를 나타내고 567번지라고합니다.

가상 메모리를 나타내는 표현에서 D (distance) 물리 메모리로변환 돼서의 D와 같은 값을 갖습니다.
페이지와 프레임의 크기를 똑같은 크기로 나눠주었기 때문입니다.
이러한 변환은 **페이지 테이블**을 통해서 변환해줄 수 있습니다.
### 페이지 테이블 구조
>페이지 테이블은 가상 주소의 페이지와 연결되는 부분과 물리 주소의 프레임과 연결되는 부분이 있어야합니다.
때문에 페이지 테이블은 페이지 번호와 프레임 번호로 구성됩니다.
이러한 각각의 구성을 **페이지 테이블 엔트리** 라고합니다.
따라서 페이지 테이블 엔트리는 페이지 번호와 프레임 번호에 대한 정보를 갖고있어야합니다.
**하지만!!!!**
사실 페이지 테이블 엔트리는 프레임 번호만 갖고있습니다!
왜냐하면, 페이지 테이블에서 페이지 번호는 순서대로 0 부터 정렬되어서 정리되어있기 때문에 굳이 페이지 번호를 표시할 필요가 없습니다.
예를 들어서, 페이지 테이블에서 첫번째의 프레임 번호가 5 라면 0번째(첫번째) 페이지는 5번 프레임으로 간다는 것을 의미합니다.
_만약 페이지 테이블이 페이지번호와 프레임 번호로 구성되어있다면 페이지 번호가 순서대로 저장되어 있지 않은 경우를 의미합니다.

---

### 주소 변환의 예
> 우리는 이제 가상 주소 번지 수를 안다면 페이징 테이블을 통해서 그에 연결되는 물리 주소 번지 수 에 접근할 수 있다.
예를 들어서, 한 페이지의 크기가 10byte이고 가상 주소가 155 라면 155를 10으로 나눈 몫은 15이고 나머지는 5가 됩니다. 따라서 이를 간단하게 VA=<15,5> 로 나타낼 수 있습니다.
- P : 가상 주소 / 한 페이지 크기 의 몫
- D : 가상 주소 / 한 페이지 크기 의 나머지
또 다른 예시로 만약 한 페이지의 크기가 2^10 byte 라고 하고 가상 메모리의 크기가 16bit 즉, 2^16이라고 한다면 전체 페이지 개수는 2^16/2^10 으로 2^6 개의 페이지를 갖을 수 있게됩니다.
이는 우리가 6bit로 페이지의 개수를 표현할 수 있다는 것입니다. 그렇다면 자연스럽게 나머지 10bit는 페이지 거리를 표현하는데 사용되는 것입니다.
![](https://velog.velcdn.com/images/parksegun/post/772e4f76-a7c2-4adc-af07-e26db41fe0ef/image.png)

#### 그렇다면 프레임은?
![](https://velog.velcdn.com/images/parksegun/post/63dcbb97-bd94-4511-a667-c0f1c7deef3a/image.png)
>이론적이라면 위에 사진에서 프레임은 최대 2^16byte의 메모리를 갖을 수 있지만 실제 최대 메모리가 아니어도 잘 작동한 다는 것을 으미하기위해 도식화하였다.
프레임도 같은 크기로 잘라주고 페이징 했던 방식과 같이 진행합니다.

 https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-14%ED%8E%B8-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EC%9A%94-%ED%8E%98%EC%9D%B4%EC%A7%95

## 페이지 테이블 관리
![](https://velog.velcdn.com/images/parksegun/post/84145bb3-37a5-46b3-8424-2edd09ce37c5/image.png)
>여러 프로세스들은 각각 페이지 테이블을 하나씩 갖게됩니다. 또한 페이지 테이블은 메모리 관리자가 자주 사용해야하는 자료 구조이므로 빠르게 접근할 수 있어야 하기에 물리 메모리 영역중에서 **운영체제 영역의 일부(PTBR)**에 저장이됩니다.
그렇다면, 한번에 실행해야 하는 프로세스의 수가 많아진다면 운영체제 영역에 저장해야하는 페이지 테이블의 크기도 같이 많아질 것이고 실제로 사용할 수 있는 물리 메모리 영역이 줄어드는 것입니다.
_추가로 물리 메모리 영역이 부족하다면 프로세스뿐만 아니라 페이지 테이블로 스왑영역으로 이동할 수 있습니다_
예를 들어서, 32bit CPU는 4GB 크기의 메모리를 갖게되고 4KB로 페이지를 나눈 시스템이 있다고 한다면 2^32/2^12= 2^20 으로 페이지 테이블은 최대 4MB 크기가 됩니다. 페이지 테이블 하나가 4MB이고 만약 프로세스가 100개라면 400MB가 되게 됩니다.
**따라서, 페이지 테이블의 크기를 적절하게 유지하는 것이 테이블 관리의 핵심입니다.**

### 페이지 테이블 기준 레지스터(PTBR)
> 각각의 프로세스들이 메모리에 접근하려고할 때 메모리 관리자는 빠르게 테이블의 위치를 찾아서 접근해야 합니다. 이 방식대로 빠르게 접근하기 위해서 **레지스터**가 사용됩니다.
- 각각의 페이지 테이블의 시작주소를 **페이지 테이블 기준 레지스터**에 보관합니다.
- 페이지 테이블 기준 레지스터는 프로세스의 PCB(프로세스 제어 블록)에 저장됩니다.
_PCB : 포로세스를 관리하기위해 필요한 정보가 들어있습니다. 운영체제는 프로세스 전환 시에 이 정보를 참조해서 프로세스의 상태를 관리하고 Context_Switching을 수행합니다._

# 페이지 테이블 매핑 방식
>이전에 설명했던 것처럼 사용되는 프로세스들이 많아질수록 물리 메모리의 사용자 영역이 줄어들게됩니다. 때문에 페이지 매핑 방식이 중요합니다.
- 직접 매핑
- 연관 매핑
- 집합-연관 매핑
- 역매핑

## 직접 매핑(direct mapping)
- 가장 단순한 방식
- 모든 페이지 테이블을 물리 메모리의 운영체제 영역에 저장(PTBR)
- 바로 주소 변환이 가능하기때문에 속도가 빠르다.
- 물리 메모리가 충분할때 사용가능

## 연관 매핑(associative mapping)
- 모든 페이지 테이블을 스왑영역에 올려놓고 **무작위**로 일부만 물리 메모리에 저장해서 사용하는방식
- 물리 메모리가 충분하지 않을때 사용하는 방식입니다.
  - 물리 메모리를 절약할 수 있다.
- 물리 메모리에 무작위 순서로 저장하기 때문에 따로 어떤 페이지에 대칭하는지에 대한 정보가 필요하다
- 2개의 열을 사용해야합니다(직접 매핑은 1개의 열).
  - 이전의 페이지 테이블을 순서대로 저장이 되어있기때문에 인덱스 역할을 해줘서 빠르게 접근할 수 있지만 연관 매핑은 한번 순회해야 하는 단점이 있습니다.
  - 페이지 번호에 대한 정보가 저장되어있지 않기때문에 하나의 열을 추가해줘야한다.
  - 또한 물리 메모리에 있지 않은 페이지라면 다시 스왑 영역과 교환해서 가져와야 한다는 단점이 있습니다.
**무작위로 물리 메모리에 저장된 페이지 테이블을 변환 색인 버퍼(Tranlsation Look-aside Buffer : TLB) 또는 연관 레지스터(associate register) 라고 합니다.

### 연관 매핑 방식
 ![](https://velog.velcdn.com/images/parksegun/post/e4a3940b-bf99-4a10-a25c-ee0a9d5d2731/image.png)
 >연관 매핑 방식을 일부 페이지 테이블만 물리 메모리에 저장되어있기 때문에 작동하는 방식이 캐시 시스템과 유사합니다. 
캐시 시스템 에서 원하는 데이터가 있으면 Cache Hit, 없는 경우는 Cache Miss 라고 하는데, 연관 매핑 방식에서도 유사합니다.
먼저 **변환 색인 버퍼(TLB)**를 먼저 탐색합니다. 있는 경우는 **TLB HIT**라고 하고 바로 물리 주소로 변경됩니다. 없는 경우는 **TLB MISS** 라고 하고 스왑 영역에 저장된 직접 매핑 테이블을 이용해서 변환합니다.

## 집합-연관 매핑(set-associative mapping)
![](https://velog.velcdn.com/images/parksegun/post/ba12191f-58ff-4239-b45b-aa0863eb4022/image.png)
- 일부만 물리 메모리로 가져오고 나머지는 스왑 영역에서 관리(연관 매핑과 동일)
- 연관 매핑은 무작위로 올라왔기 때문에 이러한 단점을 해결하기 위한 방법
>이름에서 알 수 있듯이 페이지 테이블을 순서에 맞게 일정한 크기만큼 잘라서 집합으로 묶어줍니다. ex) 1~10 1번 11~20 2번
이렇게 만든 페이지 테이블 집합을 물리 메모리로 가져옵니다. 만들어진 페이지 테이블은 찾고자 하는 정보가 스왑 영역에 있는지 물리 메모리에 있는지를 확인하는 정보를 갖고있습니다.
때문에, 전체 페이지 테이블을 탐색하지 않아도 TLB 미스를 바로 확인할 수 있기때문에 연관 매핑의 단점을 해결했습니다.
이러한 특징 으로 **멀티 페이지 매핑(multi page mapping)이라고도 합니다.**
### 주의할 점
- 10개의 페이지를 집합으로 설정하는 것이아닌 10개의 페이지 테이블(행)을 하나로 묶어서 내보내는것이다
- 집합-연관 매핑은 테이블 구성 방식이 다르다 -> 127번지는 <12,7>로 표기되었지만 집합-연관 매핑 에서는 <1,2,7>로 표기됩니다.


## 역 매핑
>이름에서 알 수 있듯이 정보를 반대로 저장한 페이지 테이블을 의미합니다.
지금까지 테이블에 페이지 번호를 기준으로 테이블을 구성했다면, **역매핑에서는 프레임 번호를 기준으로 테이블을 구성합니다.**  즉, 테이블의 프레임 번호를 기준으로 구성됩니다. (기존은 페이지 번호를 기준)
가장 큰 특징은 프레임 번호를 기준으로 테이블이 구성되어있기때문에 **프로세스의 수와 상관 없이 테이블이 하나만 존재하기 때문에 테이블의 크기가 매우 작다는 것**입니다.

**PID를 저장하는 이유는 무엇인가?**
프레임 번호로 페이지 번호를 찾게되어도 페이지 번호에 여러 프로세스들이 있을 것입니다(여러 프로세스들이 하나의 페이지 테이블에 저장되기때문). 때문에 PID를 이용해서 찾고자 하는 프로세스를 정확하게 찾아내는 것입니다.
- 테이블 구성 방식 : <프레임 번호, 프로세스 아이디, 페이지 번호>
![](https://velog.velcdn.com/images/parksegun/post/67c86f32-ba7e-4d1c-b259-930e435d31a5/image.png)
프레임 번호는 순서대로 주어져서 인덱스처럼 빠르게 접근할 수 있을까 싶지만  페이지 번호를 찾아야 하기때문에 모든 테이블을 탐색해서 찾아야한다는 단점이 있습니다.
또한 모든 탐색후에 없다면 찾는 값이 스왑 역영에 있다는 것을 알게되므로 느립니다.
이러한 단점은 연관 매핑과 비슷합니다.

