# Process

## 프로세스

- 프로그램이 메모리에 올라가서 작업을 진행하는 형태

## 프로세스의 구조

- PCB : 운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조
  - 코드 : 프로그램이 작성된 코드
  - 데이터 : 전역, static 변수가 저장
  - 힙 : 사용자가 동적 할당하는 공간 아래에서 위로 증가
  - 스택 : 지역 변수, 매개 변수 등을 저장, 위에서 아래로 증가

## 프로세스의 상태

- New : 프로세스 생성
- Running : CPU에서 명령 실행 중
- Watiting : 프로세스가 어떤 event가 발생하기를 기다리는 중
- Ready : 프로세스가 CPU에 할당되어 실행되기를 기다리는 중
- Terminated : 프로세스 실행 종료

## 프로세스 제어 블록 (PCB)

프로세스에 대한 모든 정보가 모여있는 곳으로 TCB(Task Control Block)이라고도 한다.

- PC(Program Counter)
  : 현재 실행할 명령어의 주소를 가리키는 레지스터
- SP(Stack Pointer)
  : 실행 중인 프로세스의 스택(Stack)의 최상단을 가리키는 레지스터

## Context Switch

- CPU는 한 번에 하나의 작업밖에 처리하지 못하기 때문에 새로운 작업을 처리하기 위해서는 해당 작업의 PCB에 저장된 프로세스의 상태를 읽어와야합니다.

1. 이 과정에서 현재 작업 중인 정보를 현재 PCB에 업데이트
2. 현재 PCB를 메인 메모리에 저장
3. 새로 작업할 프로세스의 PCB를 메인 메로리에서 가져옴

- 이 과정에서 오버헤드? 인터럽트? 가 발생하여 시간 손실이 발생하지만 시간이 매우 적기 때문에 많은 작업이 아닌 경우에는 사용자는 동시에 진행하는 것처럼 느낌

# Thread

## 스레드란?

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위

## 스레드 특징

- 하나의 프로세스에는 여러 스레드들이 존재할 수 있는데
- 프로세스의 코드, 데이터, 힙을 공유하고
- 스레드의 스택, PC, 레지스터 → TCB 정보에 개별적에 저장

### 멀티 스레드

- 하나의 프로세스 여러 개의 스레드를 이용하여 작업을 진행합니다.

### 멀티스레드 사용하는 이유 뭐냐?

컨텍스트 스위칭이 빈번하게 발생하기 때문에 오버헤드가 큽니다.

하지만 멀티스레드의 경우에는 프로세스의 자원을 공유(힙, 코드, 데이터)를 공유하기 때문에 상대적으로 오버헤드가 적어서 더 좋은 효율을 보입니다.

### 멀티 프로세스가 필요한 경우가 뭐냐?

멀티 스레드의 경우 사용자 레벨 스레드를 통해 구현을 하게 되는데

이 때 사용자 레벨 스레드 중 하나라도 작동에 이상이 생기게 되면 모든 프로세스의 동작에 이상이 생기게 됩니다.

### 사용자 레벨 스레드

- 프로세스 당 여러 개 존재
- 사용자 단에서 생성 및 관리하는 스레드
- 커널 모드의 전환이 필요없기 때문에 빠르다
- 프로세스 단위 블록킹 발생

### 커널 레벨 스레드

- 프로세스 당 하나만 존재
- 커널 단에서 생성 및 관리하는 스레드
- 유저 모드와 커널 모드로의 전환 빈번하기 때문에 느리다
- 커널 제공하기 때문에 안정적이다
